id     = "FF"
name   = "Finite Field Theory"

[[option]]
  name       = "ffTraceGb"
  category   = "expert"
  long       = "ff-trace-gb"
  type       = "bool"
  default    = "true"
  help       = "use a traced groebner basis engine"

[[option]]
  name       = "ffFieldPolys"
  category   = "expert"
  long       = "ff-field-polys"
  type       = "bool"
  default    = "false"
  help       = "include field polynomials in Groebner basis computation; don't do this"

[[option]]
  name       = "ffDisjunctiveBit"
  category   = "expert"
  long       = "ff-disjunctive-bit"
  type       = "bool"
  default    = "false"
  help       = "leave disjunctive bit constraints (or (= x 1) (= x 0)) alone; otherwise, preprocess to (= (* x x) x)"

[[option]]
  name       = "ffBitsum"
  category   = "expert"
  long       = "ff-bitsum"
  type       = "bool"
  default    = "false"
  help       = "parse bitsums"


[[option]]
  name       = "ffSolver"
  category   = "expert"
  long       = "ff-solver=MODE"
  type       = "FfSolver"
  default    = "GB"
  help       = "which field solver (default: 'gb'; see --ff-solver=help)"
  help_mode  = "Which field solver"
[[option.mode.GB]]
  name = "gb"
  help = "use a groebner basis for the whole system"
[[option.mode.SPLIT_GB]]
  name = "split"
  help = "use multiple groebner bases for partitions of the system"
[[option.mode.INT]]
  name = "int"
  help = "use integer reasoning (z3)"

[[option]]
  name       = "ffrGauss"
  category   = "expert"
  long       = "ffr-gauss"
  type       = "bool"
  default    = "true"
  help       = "do gaussian elimination in the range solver"

[[option]]
  name       = "ffrBoundQuotient"
  category   = "expert"
  long       = "ffr-bound-quotient"
  type       = "bool"
  default    = "true"
  help       = "bound quotient ranges in the range solver"

[[option]]
  name       = "ffrNeTighten"
  category   = "expert"
  long       = "ffr-ne-tighten"
  type       = "bool"
  default    = "true"
  help       = "use disequalities (ne) to tighten ranges"

[[option]]
  name       = "ffrMod"
  category   = "expert"
  long       = "ffr-mod"
  type       = "bool"
  default    = "false"
  help       = "use explicit modulus in integer encoding"

[[option]]
  name       = "ffrNeNorm"
  category   = "expert"
  long       = "ffr-ne-norm"
  type       = "bool"
  default    = "true"
  help       = "encode disequalities through normalization (instead of inverses)"

[[option]]
  name       = "ffrElimBits"
  category   = "expert"
  long       = "ffr-elim-bits"
  type       = "bool"
  default    = "true"
  help       = "eliminate bits if they're only used in a bit-sum"

[[option]]
  name       = "ffrCse"
  category   = "expert"
  long       = "ffr-cse"
  type       = "bool"
  default    = "true"
  help       = "run common sub-expression elimination for +"

[[option]]
  name       = "ffrIntTimeout"
  category   = "expert"
  long       = "ffr-int-timeout=MS"
  type       = "uint64_t"
  default    = "10000"
  help       = "milliseconds for unsound (SAT only) solving; 0: no limit; 1: skip"

[[option]]
  name       = "fflGbTimeout"
  category   = "expert"
  long       = "ffl-gb-timeout=MS"
  type       = "double"
  default    = "10000.0"
  help       = "milliseconds for GB construction in ffl solver; 0: no limit"

[[option]]
  name       = "fflMcCegar"
  category   = "expert"
  long       = "ffl-mc-cegar"
  type       = "bool"
  default    = "true"
  help       = "use counterexamples to guide MC abstraction refinement"

[[option]]
  name       = "fflMcLinear"
  category   = "expert"
  long       = "ffl-mc-linear"
  type       = "bool"
  default    = "true"
  help       = "use the linear ideal to drive model construction"
